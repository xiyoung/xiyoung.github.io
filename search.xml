<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx--基础篇]]></title>
    <url>%2F2018%2F07%2F18%2FNginx--%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是Nginx Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器 。 安装 Centos6.5为例，这里我们选择用压缩包安装 准备安装环境： 1.1安装gcc 安装Ngnix需要将官网下载的源码进行编译，而Nginx是c开发的，所以需要gcc的编译环境，注意切换到root用户。 1[root@localhost ~]# yum install gcc-c++ 1.2安装PCRE Ngnix的http模块需要使用pcre来解析正则表达式 。 1[root@localhost ~]# yum install -y pcre-devel 在询问是否下载时输入y 1.3安装zlib Ngnix使用zlib对http包的内容进行gzip 。 1[root@localhost ~]# yum install -y zlib zlib-devel 1.4安装OpenSSl OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常见的密钥、证书封装管理功能及SSL协议。这是为nginx的https服务提供支持的。 1[root@localhost ~]# yum install -y openssl openssl-devel 下载nginx压缩包：这里使用的是nginx-1.10.2.tar.gz，在nginx官网找到当前稳定版。 1234//进入用户目录下载程序[root@localhost ~]# cd /usr/local/src//下载压缩包[root@localhost src]# wget http://nginx.org/download/nginx-1.10.2.tar.gz 安装Nginx 12345//解压[root@localhost src]# tar zxvf nginx-1.10.2.tar.gz//编译[root@localhost src]# cd nginx-1.10.2[root@localhost nginx-1.10.2]# ./configure &amp;&amp; make &amp;&amp; make install 启动Nginx 123456789//先找一下Nginx安装在了什么位置[root@localhost nginx-1.10.2]# whereis nginx 一般会出现 nignx /usr/local/nginx//进入/usr/local/nginx[root@localhost nginx-1.10.2]# cd /usr/local/nginx//执行启动命令[root@localhost nginx]# sbin/nginx//在浏览器输入服务器外网ip地址，出现 Welcome to nginx! 表示安装成功 Nginx常用命令 12345678910111213启动[root@localhost ~]# /usr/local/src/nginx/sbin/nginx同先进入/usr/local/nginx文件夹再执行sbin/nginx停止[root@localhost ~]# /usr/local/src/nginx/sbin/nginx -s stop验证配置文件是否正确[root@localhost ~]# /usr/local/src/nginx/sbin/nginx -t编辑配置文件[root@localhost ~]# vim /usr/local/src/nginx/conf/nginx.conf配置文件修改后需要重启才能生效[root@localhost ~]# /usr/local/src/nginx/sbin/nginx -s reload查看Nginx进程信息[root@localhost ~]# ps -aux | grep ngnix 目录结构 12345678910111213141516171819202122232425262728293031323334[root@localhost ~]# tree /usr/local/src/nginx//如果提示tree命令不存在先安装 yum install tree/usr/local/nginx├── client_body_temp├── conf # Nginx所有配置文件的目录│ ├── fastcgi.conf # fastcgi相关参数的配置文件│ ├── fastcgi.conf.default # fastcgi.conf的原始备份文件│ ├── fastcgi_params # fastcgi的参数文件│ ├── fastcgi_params.default # 所有结尾为default的文件都是备份文件│ ├── koi-utf│ ├── koi-win│ ├── mime.types # 媒体类型│ ├── mime.types.default│ ├── nginx.conf # Nginx主配置文件│ ├── nginx.conf.default│ ├── scgi_params # scgi相关参数文件│ ├── scgi_params.default │ ├── uwsgi_params # uwsgi相关参数文件│ ├── uwsgi_params.default│ └── win-utf├── fastcgi_temp # fastcgi临时数据目录├── html # Nginx默认站点目录│ ├── 50x.html # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面│ └── index.html # 默认的首页文件├── logs # Nginx日志目录│ ├── access.log # 访问日志文件│ ├── error.log # 错误日志文件│ └── nginx.pid # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件├── proxy_temp # 临时目录├── sbin # Nginx命令目录│ └── nginx # Nginx的启动命令├── scgi_temp # 临时目录└── uwsgi_temp # 临时目录 日志类型 包括了：error.log和access.log 通过nginx.conf配置文件中log_format来定义要记录的变量格式来记录日志 可以被记录到日志中的变量 HTTP请求变量 arg_PARAMETER：request请求的参数 http_HEADER：request请求的header sent_http_HEADER：服务端返回的header 内置变量 Nginx内置 自定义变量 配置文件 123456789101112131415161718192021222324252627282930313233343536373839########### 每个指令必须有分号结束。##################user administrator administrators; #配置用户或者组，默认为nobody nobody。#worker_processes 2; #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid; #指定nginx进程运行文件存放地址error_log log/error.log debug; #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emergevents &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off #use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #最大连接数，默认为512&#125;http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #access_log off; #取消服务日志 log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; #自定义格式 access_log log/access.log myFormat; #combined为日志格式的默认值 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; error_page 404 https://www.baidu.com; #错误页 server &#123; keepalive_requests 120; #单连接请求上限次数。 listen 4545; #监听端口 server_name 127.0.0.1; #监听地址 location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 #root path; #根目录 #index vv.txt; #设置默认页 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip &#125; &#125;&#125;]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mocha&Chai]]></title>
    <url>%2F2018%2F07%2F17%2FMocha%2F</url>
    <content type="text"><![CDATA[For example1234567891011121314151617// add.test.jsconst mocha = require('mocha');const expect = require('chai').expect;//要测试的函数function add(x, y) &#123; return x + y;&#125;//测试函数 describe 表示测试套件，是一序列相关程序的测试describe('加法函数的测试', function() &#123; //it表示单元测试(unit test)，也就是测试的最小单位。 it('1 加 1 应该等于 2', function() &#123; //断言 expect(add(1, 1)).to.be.equal(2); &#125;);&#125;); Mocha: 现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。 常见测试类型 常规函数测试 异步函数测试(demo05) timeout类型 async类 promise http 测试 123//在工程中可用chai搭配chai-htt chai.use(chai-http);//亦可另开启一个服务监听另一个端口 let server = app.listen(9900); 常用命令行参数 –reporter :用来指定报告的格式 1//用法：mocha --reporter spec 默认spec格式，亦可npm其他格式，如：dot matrix, nyan, mochawesome(第三方)等 –watch :参数用来监视指定的测试脚本。只要测试脚本有变化就自动运行mocha –bail：参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例 –grep：参数用来搜索单元测试用例的名称,然后运行符合搜索条件的测试用例,支持正则表达 1//用法：mocha --grep /2/ ./demo*/*.test.js –invert：参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。 –recursive 1//一般如果运行mocha，会执行当前目录下的test目录的一级层级的所有js文件，但是test下的更多层级却没办法运行，这时就需要参数–recursive，这时test子目录下面所有的测试用例----不管在哪一 层----都会执行。 mocha的生命钩子 before()：在该区块的所有测试用例之前执行 after()：在该区块的所有测试用例之后执行 beforeEach()：在每个单元测试前执行 afterEach()：在每个单元测试后执行 12345678910111213141516171819202122232425262728293031describe('hooks', function () &#123; let i = 1 let j = 1 let m = 1 let n = 1 before(function () &#123; console.log("the " + i++ + " start") &#125;); after(function () &#123; console.log("the " + j++ + " end") &#125;); beforeEach(function () &#123; console.log("the " + m++ + " start") &#125;); afterEach(function () &#123; console.log("the " + n++ + " start") &#125;); it('one', function (done) &#123; done() &#125;) it('two', function (done) &#123; done() &#125;)&#125;);//测试可以出现在before,after或者和你的钩子函数交替出现。钩子函数会按照它们被定义的顺序运行。一般就是，//before()(只运行一次)-&gt;beforeEach()-&gt;afterEach()-&gt;after()(只运行一次)。 ​ 浏览器测试(demo08) 1mocha init demo08 配置文件mocha.opts的配置 1// mocha.opts –recursive –growl –reporter tap 12 关于什么时候用done()？ 在测试异步代码的时候，需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为done)给it()方法，Mocha就会知道，它应该等这个函数被调用的时候才能完成测试，否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。 摩卡测试用例时间限制？ mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。所以我们在进行异步操作的时候，需要额外指定timeout时间 12&gt; mocha --timeout 5000 user.test.js&gt; ​ Chai: 一个比较优秀的断言库，包含三种断言style,即assert，expect或should，本文采用expect。所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。 语法：==》 官网http://www.chaijs.com/api/bdd/]]></content>
      <tags>
        <tag>mocha</tag>
        <tag>chai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT]]></title>
    <url>%2F2018%2F07%2F17%2FJWT%2F</url>
    <content type="text"><![CDATA[加密算法可逆 对称性加密算法：加密和解密使用同一个密钥，常见的有AES、DES、3DES。 非对称算法：密和解密所使用的不是同一个密钥，通常有两个密钥，称为”公钥”和”私钥”，它们两个必需配对使用，常见的有RSA-X系列。 其他，如base64。 不可逆 散列算法：是一种单向加密算法，对不同长度的输入消息，产生固定长度的输出，常用来签名，常见的有HMAC-X系列、SHA-X系列、MD5。 三种常见加密算法 SHA：作用与MD5类似 RSA：由公钥(pub_key)和私钥(pri_key)组成，成对出现(可由工具生成)，任一方作为key加密message，可通过对方key解密得到message。 base64：不算加密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(其实还有一个“=“用作填充字符) HMAC：以一个key(密钥)和一个message(消息)为输入，结合一种加密散列函数(如MD5、SHA1等)生成一个消息摘要。形式为Hmac-X JWT介绍：一种开放式的标准，用于把以json对象传输的信息通过数字签名进行验证和信任，签名方式可使用HMAC(哈希算法)或RSA(公钥/私钥)。 常见有： HMAC算法 消息摘要长度 Hmac-MD5 128 Hmac-SHA1 160 Hmac-SHA256 256 Hmac-SHA384 384 Hmac-SHA512 512 相比session认证的优点 session保存在内存中，用户量增多以后会占用大量内存 服务器集群要做共享session–可用redis解决 session是基于cookie来识别用户的，cookie被劫持，服务器会受到跨站请求伪造攻击 对于ios/android应用，不方便用session JWT的构成 第一部分我们称它为头部（header) 12345//定义一个header，例：&#123; 'typ': 'JWT', 'alg': 'HS256'&#125; 第二部分我们称其为载荷（payload) 标准中注册的声明 1234567iss(Issuer): //jwt签发者sub(Subject): //jwt所面向的用户aud(Audience): //接收jwt的一方exp(Expiration time): //jwt的过期时间，这个过期时间必须要大于签发时间nbf(Not before): //定义在什么时间之前，该jwt都是不可用的.iat(Issued at): //jwt的签发时间jti(JWT ID): //jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分可解密 私有的声明 私有声明是提供者和消费者所共同定义的声明 123456//定义一个payload，例：&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125; 第三部分是签名（signature) header (base64后的) payload (base64后的) secret(也可为base64后的)——只能保存在服务器端切不可泄露 12345//定义一个signature，例// base64加密后的header和base64加密后的payloadvar encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);//这里使用HMACSHA256算法签名var signature = HMACSHA256(encodedString, 'secret'); token应用流程 登录：用户登录，输入用户名密码 密码验证：服务器从数据库取出用户名和密码进行验证 生成JWT：服务器端验证通过，根据从数据库返回的信息，以及预设规则，生成JWT 返还JWT：服务器的HTTP RESPONSE中将JWT返还 带JWT的请求：以后客户端发起请求，HTTP REQUEST HEADER中的Authorizatio字段都要有值，为JWT 验证JWT：服务端验证JWT，获取用户信息，如不通过则请求异常]]></content>
      <tags>
        <tag>jwt</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise的实现]]></title>
    <url>%2F2018%2F07%2F16%2Fpromise%2F</url>
    <content type="text"><![CDATA[准备工作 回调函数 123456789101112131415161718//回掉函数的参数为常量function Cc_1 (callback)&#123; callback(50);&#125;new Cc_1(function(a)&#123; console.log(a)&#125;)//回调函数的参数为方法function Cc_2(callback) &#123; function resolve(value) &#123; console.log(value) &#125; callback(resolve)&#125;new Cc_2(function(a)&#123; a(100)&#125;) 函数的链式调用 1234567891011121314151617181920212223var obj = &#123; step1:function()&#123; console.log('a'); return this; &#125;, step2:function()&#123; console.log('b'); return this; &#125;, step3:function()&#123; console.log('c'); return this; &#125;, step4:function()&#123; console.log('d'); return this; &#125; &#125; console.log('-----\n'); obj.step1().step2().step3(); console.log('-----\n'); obj.step4().step2().step1(); Promise极简雏形123456789101112131415161718192021222324252627function Promise(fn)&#123; var callback; this.then = function(done)&#123; callback = done;//储存then传入的回调函数 &#125; function resolve(value)&#123; callback(value);//执行回调函数 &#125; fn(resolve);&#125;new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(50) &#125;,0) &#125;) .then((a) =&gt; &#123; console.log(a) &#125;)//问题1：当promise实例处理的不是一个异步函数的时候，会报错，原因是执行回调函数的代码比储存回调函数的代码 先执行//问题2：无法链式调用//问题3：没有状态，无法控制状态的单向转化//问题4：链式传值//问题5：不能串行执行promise//问题6：失败处理(reject)............ 解决问题 1 2 –异步执行回调函数 链式调用123456789101112131415161718192021222324252627282930313233function Promise(fn) &#123; var promise = this, value = null; promise._resolves = []; //初始化储存then中回调函数的数组 this.then = function (onFulfilled) &#123; promise._resolves.push(onFulfilled); return this; //返回当前promise对象 &#125;; function resolve(value) &#123; setTimeout(() =&gt; &#123; //确保then中的回调函数已经被注册 promise._resolves.forEach(function (callback) &#123;//依次执行 callback(value); &#125;); &#125;,0) &#125; fn(resolve);&#125;new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(50) &#125;,0) &#125;) .then(function (a) &#123; console.log(a) return 2*a; &#125;) .then(function(b)&#123; console.log(b) &#125;) 解决问题 3 4 – 加入状态 链式传值12345678910111213141516171819202122232425262728293031323334353637383940function Promise(fn) &#123; var promise = this, value = null; promise._resolves = []; promise._status = 'PENDING';//初始状态 this.then = function (onFulfilled) &#123; if (promise._status === 'PENDING') &#123; promise._resolves.push(onFulfilled); return this; &#125; onFulfilled(value);//如果不是初始状态则直接执行then中的回调函数 return this; &#125;; function resolve(value) &#123; setTimeout(function()&#123; promise._status = "FULFILLED"; promise._resolves.forEach(function (callback) &#123; value = callback(value); //将回调函数的返回值赋给value &#125;) &#125;,0); &#125; fn(resolve);&#125;new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(50) &#125;,0) &#125;) .then(function (a) &#123; console.log(a) return 2*a; &#125;) .then(function(b)&#123; console.log(b) &#125;) 解决问题 5 串行执行promise1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Promise(fn) &#123; var promise = this, value = null; promise._resolves = []; promise._status = 'PENDING';//初始状态 //then函数改变有二：一是then函数不再返回this，而是一个新的promise实例； //二是_resolves数组中储存的不再是回调函数了，而是handle函数，这个handle函数对上一 个 promise 的 then 中的回调函数进行了处理，并调用新的promise实例中的resolve方 法，以便处理then 中的回调函数返回值为Promise的情况 this.then = function (onFulfilled) &#123; return new Promise(function(resolve) &#123; function handle(value) &#123; var ret = typeof onFulfilled === 'function' &amp;&amp; onFulfilled(value) || value; if( ret &amp;&amp; typeof ret ['then'] == 'function')&#123;//如果then回调函数中返回的是promise对象 ret.then(function(value)&#123;//执行promise对象使其状态变为非'pending'状态 resolve(value); &#125;); &#125; else &#123; resolve(ret); &#125; &#125; if (promise._status === 'PENDING') &#123; promise._resolves.push(handle); &#125; else if(promise._status === 'FULFILLED')&#123; handle(value); &#125; &#125;) &#125;; function resolve(value) &#123; setTimeout(function()&#123; promise._status = "FULFILLED"; promise._resolves.forEach(function (callback) &#123; value = callback(value); //将回调函数的返回值赋给value &#125;) &#125;,0); &#125; fn(resolve);&#125;new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(50) &#125;,0) &#125;) .then(function (a) &#123; console.log(a) return new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(2*a) &#125;,0) &#125;); &#125;) .then(function(b)&#123; console.log(b) &#125;) 其他问题 失败处理(reject) 以及实现 .catch() 封装Promise静态方法 Promise.all() Promise.race() Promise.resolve() Promise.reject() 123456789101112131415161718192021222324252627282930313233function fn1(resolve, reject) &#123; setTimeout(function() &#123; console.log('步骤一：执行'); resolve('1'); &#125;,500);&#125;function fn2(data) &#123; console.log(data) return data;&#125;function fn3(data) &#123; console.log(data)&#125;new Promise(fn1).then(fn2).then(fn3)//这段代码的执行过程：//首先我们创建了一个 Promise 实例，这里叫做 promise1；接着会运行 fn1(resolve);//但是 fn1 中有一个 setTimeout 函数，于是就会先跳过这一部分，运行后面的第一个 then 方法;//then 返回一个新的对象 promise2, promise2 对象的 resolve 方法和 then 方法的中回调函数 fn2 都被封装在 handle 中， 然后 handle 被添加到 promise1._resolves 数组中。//接着运行第二个 then 方法，同样返回一个新的对象 promise3, 包含 promise3 的 resolve 方法和 回调函数 fn3 的 handle 方法被添加到 promise2._resolves 数组中。//到此两个 then 运行结束。 setTimeout 中的延迟时间一到，就会调用 promise1的 resolve方法。//resolve 方法的执行，会调用 promise1._resolves 数组中的回调，之前我们添加的 handle 方法就会被执行； 也就是 fn2 和 promsie2 的 resolve 方法，都被调用了。//以此类推，fn3 会和 promise3 的 resolve 方法 一起执行，因为后面没有 then 方法了，promise3._resolves 数组是空的 。//至此所有回调执行结束]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
</search>
