<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiyoung</title>
  
  <subtitle>Be enjoyed.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.xixiyoung.com/"/>
  <updated>2018-07-18T09:41:25.099Z</updated>
  <id>http://blog.xixiyoung.com/</id>
  
  <author>
    <name>xiyoung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx--基础篇</title>
    <link href="http://blog.xixiyoung.com/2018/07/18/Nginx--%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://blog.xixiyoung.com/2018/07/18/Nginx--基础篇/</id>
    <published>2018-07-18T09:40:22.000Z</published>
    <updated>2018-07-18T09:41:25.099Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>什么是Nginx</p><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 <strong><a href="https://baike.baidu.com/item/WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/8390210" target="_blank" rel="noopener">Web</a></strong>和 <strong><a href="https://www.cnblogs.com/Anker/p/6056540.html" target="_blank" rel="noopener">反向代理</a></strong> 服务器 。</p><a id="more"></a></li><li><p>安装</p><p>Centos6.5为例，这里我们选择用压缩包安装</p><ol><li><p>准备安装环境：</p><p>1.1安装gcc  </p><p>安装Ngnix需要将官网下载的源码进行编译，而Nginx是c开发的，所以需要gcc的编译环境，注意切换到root用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install gcc-c++</span><br></pre></td></tr></table></figure><p>1.2安装PCRE </p><p>Ngnix的http模块需要使用pcre来解析正则表达式 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y pcre-devel                             在询问是否下载时输入y</span><br></pre></td></tr></table></figure><p>1.3安装zlib </p><p>Ngnix使用zlib对http包的内容进行gzip 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><p>1.4安装OpenSSl </p><p>OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常见的密钥、证书封装管理功能及SSL协议。这是为nginx的https服务提供支持的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>下载nginx压缩包：这里使用的是nginx-1.10.2.tar.gz，在<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">nginx官网</a>找到当前稳定版。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入用户目录下载程序</span></span><br><span class="line">[root@localhost ~]# cd /usr/local/src</span><br><span class="line"><span class="comment">//下载压缩包</span></span><br><span class="line">[root@localhost src]# wget http://nginx.org/download/nginx-1.10.2.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装Nginx</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解压</span></span><br><span class="line">[root@localhost src]# tar zxvf nginx-1.10.2.tar.gz</span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line">[root@localhost src]# cd nginx-1.10.2</span><br><span class="line">[root@localhost nginx-1.10.2]# ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>启动Nginx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先找一下Nginx安装在了什么位置</span></span><br><span class="line">[root@localhost nginx-1.10.2]# whereis nginx 一般会出现 </span><br><span class="line">nignx /usr/local/nginx</span><br><span class="line"><span class="comment">//进入/usr/local/nginx</span></span><br><span class="line">[root@localhost nginx-1.10.2]# cd /usr/local/nginx</span><br><span class="line"><span class="comment">//执行启动命令</span></span><br><span class="line">[root@localhost nginx]# sbin/nginx</span><br><span class="line"><span class="comment">//在浏览器输入服务器外网ip地址，出现 </span></span><br><span class="line">Welcome to nginx! 表示安装成功</span><br></pre></td></tr></table></figure></li><li><p>Nginx常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">启动</span><br><span class="line">[root@localhost ~]# /usr/local/src/nginx/sbin/nginx</span><br><span class="line">同先进入/usr/local/nginx文件夹再执行sbin/nginx</span><br><span class="line">停止</span><br><span class="line">[root@localhost ~]# /usr/local/src/nginx/sbin/nginx -s stop</span><br><span class="line">验证配置文件是否正确</span><br><span class="line">[root@localhost ~]# /usr/local/src/nginx/sbin/nginx -t</span><br><span class="line">编辑配置文件</span><br><span class="line">[root@localhost ~]# vim /usr/local/src/nginx/conf/nginx.conf</span><br><span class="line">配置文件修改后需要重启才能生效</span><br><span class="line">[root@localhost ~]# /usr/local/src/nginx/sbin/nginx -s reload</span><br><span class="line">查看Nginx进程信息</span><br><span class="line">[root@localhost ~]# ps -aux | grep ngnix</span><br></pre></td></tr></table></figure></li></ol></li><li><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tree /usr/local/src/nginx</span><br><span class="line">//如果提示tree命令不存在先安装 yum install tree</span><br><span class="line"></span><br><span class="line">/usr/local/nginx</span><br><span class="line">├── client_body_temp</span><br><span class="line">├── conf                             # Nginx所有配置文件的目录</span><br><span class="line">│   ├── fastcgi.conf                 # fastcgi相关参数的配置文件</span><br><span class="line">│   ├── fastcgi.conf.default         # fastcgi.conf的原始备份文件</span><br><span class="line">│   ├── fastcgi_params               # fastcgi的参数文件</span><br><span class="line">│   ├── fastcgi_params.default       # 所有结尾为default的文件都是备份文件</span><br><span class="line">│   ├── koi-utf</span><br><span class="line">│   ├── koi-win</span><br><span class="line">│   ├── mime.types                   # 媒体类型</span><br><span class="line">│   ├── mime.types.default</span><br><span class="line">│   ├── nginx.conf                   # Nginx主配置文件</span><br><span class="line">│   ├── nginx.conf.default</span><br><span class="line">│   ├── scgi_params                  # scgi相关参数文件</span><br><span class="line">│   ├── scgi_params.default  </span><br><span class="line">│   ├── uwsgi_params                 # uwsgi相关参数文件</span><br><span class="line">│   ├── uwsgi_params.default</span><br><span class="line">│   └── win-utf</span><br><span class="line">├── fastcgi_temp                     # fastcgi临时数据目录</span><br><span class="line">├── html                             # Nginx默认站点目录</span><br><span class="line">│   ├── 50x.html                     # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面</span><br><span class="line">│   └── index.html                   # 默认的首页文件</span><br><span class="line">├── logs                             # Nginx日志目录</span><br><span class="line">│   ├── access.log                   # 访问日志文件</span><br><span class="line">│   ├── error.log                    # 错误日志文件</span><br><span class="line">│   └── nginx.pid                    # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件</span><br><span class="line">├── proxy_temp                       # 临时目录</span><br><span class="line">├── sbin                             # Nginx命令目录</span><br><span class="line">│   └── nginx                        # Nginx的启动命令</span><br><span class="line">├── scgi_temp                        # 临时目录</span><br><span class="line">└── uwsgi_temp                       # 临时目录</span><br></pre></td></tr></table></figure></li><li><p>日志类型</p><ol><li>包括了：error.log和access.log</li><li>通过nginx.conf配置文件中log_format来定义要记录的变量格式来记录日志</li><li>可以被记录到日志中的变量 <ul><li>HTTP请求变量 <ul><li>arg_PARAMETER：request请求的参数</li><li>http_HEADER：request请求的header</li><li>sent_http_HEADER：服务端返回的header </li></ul></li><li>内置变量 <ul><li>Nginx内置</li></ul></li><li>自定义变量</li></ul></li></ol></li><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">########### 每个指令必须有分号结束。#################</span><br><span class="line">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><br><span class="line">#worker_processes 2;  #允许生成的进程数，默认为1</span><br><span class="line">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="line">error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class="line">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class="line">    worker_connections  1024;    #最大连接数，默认为512</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class="line">    #access_log off; #取消服务日志    </span><br><span class="line">    log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; #自定义格式</span><br><span class="line">    access_log log/access.log myFormat;  #combined为日志格式的默认值</span><br><span class="line">    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line"></span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  #热备</span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; #错误页</span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">        listen       4545;   #监听端口</span><br><span class="line">        server_name  127.0.0.1;   #监听地址       </span><br><span class="line">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line">           #root path;  #根目录</span><br><span class="line">           #index vv.txt;  #设置默认页</span><br><span class="line">           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表</span><br><span class="line">           deny 127.0.0.1;  #拒绝的ip</span><br><span class="line">           allow 172.18.5.54; #允许的ip           </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li></li></ul><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是Nginx&lt;/p&gt;
&lt;p&gt;Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 &lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/8390210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web&lt;/a&gt;&lt;/strong&gt;和 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Anker/p/6056540.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;反向代理&lt;/a&gt;&lt;/strong&gt; 服务器 。&lt;/p&gt;
    
    </summary>
    
      <category term="server" scheme="http://blog.xixiyoung.com/categories/server/"/>
    
    
      <category term="nginx" scheme="http://blog.xixiyoung.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mocha&amp;Chai</title>
    <link href="http://blog.xixiyoung.com/2018/07/17/Mocha/"/>
    <id>http://blog.xixiyoung.com/2018/07/17/Mocha/</id>
    <published>2018-07-17T03:53:13.000Z</published>
    <updated>2018-07-17T05:04:58.786Z</updated>
    
    <content type="html"><![CDATA[<p>For example<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.test.js</span></span><br><span class="line"><span class="keyword">const</span> mocha = <span class="built_in">require</span>(<span class="string">'mocha'</span>);</span><br><span class="line"><span class="keyword">const</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要测试的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数 describe 表示测试套件，是一序列相关程序的测试</span></span><br><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//it表示单元测试(unit test)，也就是测试的最小单位。</span></span><br><span class="line">  it(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//断言</span></span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><a id="more"></a><ul><li><p><strong>Mocha</strong>: 现在最流行的JavaScript<strong>测试框架</strong>之一，在<code>浏览器</code>和<code>Node环境</code>都可以使用。</p><ul><li><p>常见测试类型</p><ul><li><p>常规函数测试</p></li><li><p>异步函数测试(demo05)</p><ul><li>timeout类型 </li><li>async类</li><li>promise</li></ul></li><li><p>http 测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在工程中可用chai搭配chai-htt chai.use(chai-http);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//亦可另开启一个服务监听另一个端口 let server = app.listen(9900);</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>常用命令行参数</p><ul><li><p>–reporter :用来指定报告的格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法：mocha --reporter spec 默认spec格式，亦可npm其他格式，如：dot matrix, nyan, mochawesome(第三方)等</span></span><br></pre></td></tr></table></figure></li><li><p>–watch :参数用来监视指定的测试脚本。只要测试脚本有变化就自动运行mocha</p></li><li><p>–bail：参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例</p></li><li><p>–grep：参数用来搜索单元测试用例的名称,然后运行符合搜索条件的测试用例,支持正则表达</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法：mocha --grep /2/   ./demo*/*.test.js</span></span><br></pre></td></tr></table></figure></li><li><p>–invert：参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。</p></li><li><p>–recursive</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般如果运行mocha，会执行当前目录下的test目录的一级层级的所有js文件，但是test下的更多层级却没办法运行，这时就需要参数–recursive，这时test子目录下面所有的测试用例----不管在哪一    层----都会执行。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>mocha的生命钩子</p><ul><li><p>before()：在该区块的所有测试用例之前执行</p></li><li><p>after()：在该区块的所有测试用例之后执行</p></li><li><p>beforeEach()：在每个单元测试前执行</p></li><li><p>afterEach()：在每个单元测试后执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">1</span></span><br><span class="line">    before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the "</span> + i++ + <span class="string">" start"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the "</span> + j++ + <span class="string">" end"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the "</span> + m++ + <span class="string">" start"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the "</span> + n++ + <span class="string">" start"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">        done()</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'two'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">        done()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试可以出现在before,after或者和你的钩子函数交替出现。钩子函数会按照它们被定义的顺序运行。一般就是，</span></span><br><span class="line"><span class="comment">//before()(只运行一次)-&gt;beforeEach()-&gt;afterEach()-&gt;after()(只运行一次)。</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>浏览器测试(demo08)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mocha init demo08</span><br></pre></td></tr></table></figure></li><li><p>配置文件mocha.opts的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mocha.opts</span></span><br></pre></td></tr></table></figure><p> –recursive<br> –growl<br> –reporter tap</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>关于什么时候用done()？</p><p>在测试异步代码的时候，需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为done)给it()方法，Mocha就会知道，它应该等这个函数被调用的时候才能完成测试，否则，Mocha就无法知道，测试是否结束，会一直等到超时报错。</p><p>摩卡测试用例时间限制？</p><p>mocha默认每个测试用例最多执行2000毫秒，如果到时没有得到结果，就报错。所以我们在进行异步操作的时候，需要额外指定timeout时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mocha --timeout <span class="number">5000</span> user.test.js</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​</p></li></ul></li><li><p><strong>Chai</strong>: 一个比较优秀的<strong>断言库</strong>，包含三种断言style,即<code>assert</code>，<code>expect</code>或<code>should</code>，本文采用<strong>expect</strong>。所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。</p><ul><li>语法：==》 官网<a href="http://www.chaijs.com/api/bdd/" target="_blank" rel="noopener">http://www.chaijs.com/api/bdd/</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;For example&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// add.test.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; mocha = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;mocha&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; expect = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;chai&#39;&lt;/span&gt;).expect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//要测试的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//测试函数 describe 表示测试套件，是一序列相关程序的测试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;describe(&lt;span class=&quot;string&quot;&gt;&#39;加法函数的测试&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//it表示单元测试(unit test)，也就是测试的最小单位。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  it(&lt;span class=&quot;string&quot;&gt;&#39;1 加 1 应该等于 2&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//断言&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expect(add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)).to.be.equal(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mocha" scheme="http://blog.xixiyoung.com/tags/mocha/"/>
    
      <category term="chai" scheme="http://blog.xixiyoung.com/tags/chai/"/>
    
  </entry>
  
  <entry>
    <title>JWT</title>
    <link href="http://blog.xixiyoung.com/2018/07/17/JWT/"/>
    <id>http://blog.xixiyoung.com/2018/07/17/JWT/</id>
    <published>2018-07-17T03:51:50.000Z</published>
    <updated>2018-07-17T05:07:32.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="可逆"><a href="#可逆" class="headerlink" title="可逆"></a>可逆</h4><ul><li>对称性加密算法：加密和解密使用同一个密钥，常见的有AES、DES、3DES。</li></ul><ul><li>非对称算法：密和解密所使用的不是同一个密钥，通常有两个密钥，称为”公钥”和”私钥”，它们两个必需配对使用，常见的有RSA-X系列。</li><li>其他，如base64。</li></ul><a id="more"></a><h4 id="不可逆"><a href="#不可逆" class="headerlink" title="不可逆"></a>不可逆</h4><ul><li>散列算法：是一种单向加密算法，对不同长度的输入消息，产生固定长度的输出，常用来签名，常见的有HMAC-X系列、SHA-X系列、MD5。</li></ul><h4 id="三种常见加密算法"><a href="#三种常见加密算法" class="headerlink" title="三种常见加密算法"></a>三种常见加密算法</h4><ul><li>SHA：作用与MD5类似</li></ul><ul><li>RSA：由公钥(pub_key)和私钥(pri_key)组成，成对出现(可由工具生成)，任一方作为key加密message，可通过对方key解密得到message。</li></ul><ul><li>base64：不算加密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(其实还有一个“=“用作填充字符)</li><li>HMAC：以一个key(密钥)和一个message(消息)为输入，结合一种加密散列函数(如MD5、SHA1等)生成一个消息摘要。形式为Hmac-X</li></ul><h3 id="JWT介绍："><a href="#JWT介绍：" class="headerlink" title="JWT介绍："></a>JWT介绍：</h3><p>一种开放式的标准，用于把以json对象传输的信息通过数字签名进行验证和信任，签名方式可使用HMAC(哈希算法)或RSA(公钥/私钥)。</p><p>常见有：</p><table><thead><tr><th>HMAC算法</th><th>消息摘要长度</th></tr></thead><tbody><tr><td>Hmac-MD5</td><td>128</td></tr><tr><td>Hmac-SHA1</td><td>160</td></tr><tr><td>Hmac-SHA256</td><td>256</td></tr><tr><td>Hmac-SHA384</td><td>384</td></tr><tr><td>Hmac-SHA512</td><td>512</td></tr></tbody></table><h3 id="相比session认证的优点"><a href="#相比session认证的优点" class="headerlink" title="相比session认证的优点"></a>相比session认证的优点</h3><ol><li><p>session保存在内存中，用户量增多以后会占用大量内存</p></li><li><p>服务器集群要做共享session–可用redis解决</p></li><li><p>session是基于cookie来识别用户的，cookie被劫持，服务器会受到跨站请求伪造攻击</p></li><li><p>对于ios/android应用，不方便用session</p></li></ol><h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><ul><li><p>第一部分我们称它为头部（header)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个header，例：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'typ'</span>: <span class="string">'JWT'</span>,</span><br><span class="line">  <span class="string">'alg'</span>: <span class="string">'HS256'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二部分我们称其为载荷（payload)</p><ol><li><p>标准中注册的声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss(Issuer): <span class="comment">//jwt签发者</span></span><br><span class="line">sub(Subject): <span class="comment">//jwt所面向的用户</span></span><br><span class="line">aud(Audience): <span class="comment">//接收jwt的一方</span></span><br><span class="line">exp(Expiration time): <span class="comment">//jwt的过期时间，这个过期时间必须要大于签发时间</span></span><br><span class="line">nbf(Not before): <span class="comment">//定义在什么时间之前，该jwt都是不可用的.</span></span><br><span class="line">iat(Issued at): <span class="comment">//jwt的签发时间</span></span><br><span class="line">jti(JWT ID): <span class="comment">//jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span></span><br></pre></td></tr></table></figure></li><li><p>公共的声明</p><p>一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分可解密</p></li><li><p>私有的声明</p><p>私有声明是提供者和消费者所共同定义的声明</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个payload，例：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三部分是签名（signature)</p><ol><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret(也可为base64后的)——只能保存在服务器端切不可泄露</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个signature，例</span></span><br><span class="line"><span class="comment">// base64加密后的header和base64加密后的payload</span></span><br><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">'.'</span> + base64UrlEncode(payload);</span><br><span class="line"><span class="comment">//这里使用HMACSHA256算法签名</span></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">'secret'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="token应用流程"><a href="#token应用流程" class="headerlink" title="token应用流程"></a>token应用流程</h3><ol><li>登录：用户登录，输入用户名密码</li><li>密码验证：服务器从数据库取出用户名和密码进行验证</li><li>生成JWT：服务器端验证通过，根据从数据库返回的信息，以及预设规则，生成JWT</li><li>返还JWT：服务器的HTTP RESPONSE中将JWT返还</li><li>带JWT的请求：以后客户端发起请求，HTTP REQUEST HEADER中的Authorizatio字段都要有值，为JWT</li><li>验证JWT：服务端验证JWT，获取用户信息，如不通过则请求异常</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加密算法&quot;&gt;&lt;/a&gt;加密算法&lt;/h3&gt;&lt;h4 id=&quot;可逆&quot;&gt;&lt;a href=&quot;#可逆&quot; class=&quot;headerlink&quot; title=&quot;可逆&quot;&gt;&lt;/a&gt;可逆&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对称性加密算法：加密和解密使用同一个密钥，常见的有AES、DES、3DES。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;非对称算法：密和解密所使用的不是同一个密钥，通常有两个密钥，称为”公钥”和”私钥”，它们两个必需配对使用，常见的有RSA-X系列。&lt;/li&gt;
&lt;li&gt;其他，如base64。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="jwt" scheme="http://blog.xixiyoung.com/tags/jwt/"/>
    
      <category term="安全" scheme="http://blog.xixiyoung.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Promise的实现</title>
    <link href="http://blog.xixiyoung.com/2018/07/16/promise/"/>
    <id>http://blog.xixiyoung.com/2018/07/16/promise/</id>
    <published>2018-07-16T07:53:22.000Z</published>
    <updated>2018-07-17T05:07:37.586Z</updated>
    
    <content type="html"><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li><p>回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回掉函数的参数为常量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cc_1</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    callback(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Cc_1(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数的参数为方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cc_2</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(resolve)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Cc_2(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>函数的链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    step1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    step2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'b'</span>);    </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    step3:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    step4:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'d'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-----\n'</span>);</span><br><span class="line">  obj.step1().step2().step3();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-----\n'</span>);</span><br><span class="line">  obj.step4().step2().step1();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise极简雏形"><a href="#Promise极简雏形" class="headerlink" title="Promise极简雏形"></a>Promise极简雏形</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback;</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">    callback = done;<span class="comment">//储存then传入的回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    callback(value);<span class="comment">//执行回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">50</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//问题1：当promise实例处理的不是一个异步函数的时候，会报错，原因是执行回调函数的代码比储存回调函数的代码 先执行</span></span><br><span class="line"><span class="comment">//问题2：无法链式调用</span></span><br><span class="line"><span class="comment">//问题3：没有状态，无法控制状态的单向转化</span></span><br><span class="line"><span class="comment">//问题4：链式传值</span></span><br><span class="line"><span class="comment">//问题5：不能串行执行promise</span></span><br><span class="line"><span class="comment">//问题6：失败处理(reject)</span></span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="解决问题-1-2-–异步执行回调函数-链式调用"><a href="#解决问题-1-2-–异步执行回调函数-链式调用" class="headerlink" title="解决问题 1 2 –异步执行回调函数 链式调用"></a>解决问题 1 2 –异步执行回调函数 链式调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">this</span>,</span><br><span class="line">        value = <span class="literal">null</span>;</span><br><span class="line">        promise._resolves = []; <span class="comment">//初始化储存then中回调函数的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        promise._resolves.push(onFulfilled);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//返回当前promise对象</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//确保then中的回调函数已经被注册</span></span><br><span class="line">            promise._resolves.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;<span class="comment">//依次执行</span></span><br><span class="line">            callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">50</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*a;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="解决问题-3-4-–-加入状态-链式传值"><a href="#解决问题-3-4-–-加入状态-链式传值" class="headerlink" title="解决问题 3 4 – 加入状态 链式传值"></a>解决问题 3 4 – 加入状态 链式传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">this</span>,</span><br><span class="line">        value = <span class="literal">null</span>;</span><br><span class="line">        promise._resolves = [];</span><br><span class="line">        promise._status = <span class="string">'PENDING'</span>;<span class="comment">//初始状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (promise._status === <span class="string">'PENDING'</span>) &#123;</span><br><span class="line">            promise._resolves.push(onFulfilled);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        onFulfilled(value);<span class="comment">//如果不是初始状态则直接执行then中的回调函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            promise._status = <span class="string">"FULFILLED"</span>;</span><br><span class="line">            promise._resolves.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                value = callback(value); <span class="comment">//将回调函数的返回值赋给value</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">50</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*a;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="解决问题-5-串行执行promise"><a href="#解决问题-5-串行执行promise" class="headerlink" title="解决问题    5 串行执行promise"></a>解决问题    5 串行执行promise</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">this</span>,</span><br><span class="line">        value = <span class="literal">null</span>;</span><br><span class="line">        promise._resolves = [];</span><br><span class="line">        promise._status = <span class="string">'PENDING'</span>;<span class="comment">//初始状态</span></span><br><span class="line">   <span class="comment">//then函数改变有二：一是then函数不再返回this，而是一个新的promise实例；</span></span><br><span class="line">                    <span class="comment">//二是_resolves数组中储存的不再是回调函数了，而是handle函数，这个handle函数对上一                       个 promise 的 then 中的回调函数进行了处理，并调用新的promise实例中的resolve方                       法，以便处理then 中的回调函数返回值为Promise的情况</span></span><br><span class="line">   <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ret = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> &amp;&amp; onFulfilled(value) || value;</span><br><span class="line">                <span class="keyword">if</span>( ret &amp;&amp; <span class="keyword">typeof</span> ret [<span class="string">'then'</span>] == <span class="string">'function'</span>)&#123;<span class="comment">//如果then回调函数中返回的是promise对象</span></span><br><span class="line">                    ret.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;<span class="comment">//执行promise对象使其状态变为非'pending'状态</span></span><br><span class="line">                       resolve(value);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(ret);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (promise._status === <span class="string">'PENDING'</span>) &#123;</span><br><span class="line">                promise._resolves.push(handle);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(promise._status === <span class="string">'FULFILLED'</span>)&#123;</span><br><span class="line">                handle(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            promise._status = <span class="string">"FULFILLED"</span>;</span><br><span class="line">            promise._resolves.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                value = callback(value); <span class="comment">//将回调函数的返回值赋给value</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">50</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="number">2</span>*a)</span><br><span class="line">            &#125;,<span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul><li>失败处理(reject) 以及实现 .catch()</li><li>封装Promise静态方法  <ul><li>Promise.all()</li><li>Promise.race()</li><li>Promise.resolve()</li><li>Promise.reject()</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤一：执行'</span>);</span><br><span class="line">        resolve(<span class="string">'1'</span>);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(fn1).then(fn2).then(fn3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码的执行过程：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先我们创建了一个 Promise 实例，这里叫做 promise1；接着会运行 fn1(resolve);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是 fn1 中有一个 setTimeout 函数，于是就会先跳过这一部分，运行后面的第一个 then 方法;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//then 返回一个新的对象 promise2,  promise2 对象的 resolve 方法和 then 方法的中回调函数 fn2 都被封装在 handle 中， 然后 handle 被添加到 　　promise1._resolves 数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着运行第二个 then 方法，同样返回一个新的对象 promise3, 包含 promise3 的 resolve 方法和 回调函数 fn3 的 handle 方法被添加到 promise2._resolves 数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//到此两个 then 运行结束。 setTimeout 中的延迟时间一到，就会调用 promise1的 resolve方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//resolve 方法的执行，会调用 promise1._resolves 数组中的回调，之前我们添加的 handle 方法就会被执行； 也就是 fn2 和 promsie2 的 resolve 方法，都被调用了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以此类推，fn3 会和 promise3 的 resolve 方法 一起执行，因为后面没有 then 方法了，promise3._resolves 数组是空的 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//至此所有回调执行结束</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回调函数&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//回掉函数的参数为常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cc_1&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;callback&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cc_1(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//回调函数的参数为方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cc_2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;callback&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callback(resolve)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Cc_2(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="es6" scheme="http://blog.xixiyoung.com/categories/es6/"/>
    
    
      <category term="promise" scheme="http://blog.xixiyoung.com/tags/promise/"/>
    
  </entry>
  
</feed>
